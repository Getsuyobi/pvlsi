$date
  Wed Jan 23 20:15:48 2019
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module math_real $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module exec_tb $end
$var reg 1 ! dec2exe_empty $end
$var reg 1 " exe_pop $end
$var reg 32 # dec_op1[31:0] $end
$var reg 32 $ dec_op2[31:0] $end
$var reg 4 % dec_exe_dest[3:0] $end
$var reg 1 & dec_exe_wb $end
$var reg 1 ' dec_flag_wb $end
$var reg 32 ( dec_mem_data[31:0] $end
$var reg 4 ) dec_mem_dest[3:0] $end
$var reg 1 * dec_pre_index $end
$var reg 1 + dec_mem_lw $end
$var reg 1 , dec_mem_lb $end
$var reg 1 - dec_mem_sw $end
$var reg 1 . dec_mem_sb $end
$var reg 1 / dec_shift_lsl $end
$var reg 1 0 dec_shift_lsr $end
$var reg 1 1 dec_shift_asr $end
$var reg 1 2 dec_shift_ror $end
$var reg 1 3 dec_shift_rrx $end
$var reg 5 4 dec_shift_val[4:0] $end
$var reg 1 5 dec_cy $end
$var reg 1 6 dec_comp_op1 $end
$var reg 1 7 dec_comp_op2 $end
$var reg 1 8 dec_alu_cy $end
$var reg 2 9 dec_alu_cmd[1:0] $end
$var reg 32 : exe_res[31:0] $end
$var reg 1 ; exe_c $end
$var reg 1 < exe_v $end
$var reg 1 = exe_n $end
$var reg 1 > exe_z $end
$var reg 4 ? exe_dest[3:0] $end
$var reg 1 @ exe_wb $end
$var reg 1 A exe_flag_wb $end
$var reg 32 B exe_mem_adr[31:0] $end
$var reg 32 C exe_mem_data[31:0] $end
$var reg 4 D exe_mem_dest[3:0] $end
$var reg 1 E exe_mem_lw $end
$var reg 1 F exe_mem_lb $end
$var reg 1 G exe_mem_sw $end
$var reg 1 H exe_mem_sb $end
$var reg 1 I exe2mem_empty $end
$var reg 1 J mem_pop $end
$var reg 1 K ck $end
$var reg 1 L reset_n $end
$var reg 1 M vdd $end
$var reg 1 N vss $end
$scope module exec_inst $end
$var reg 1 O dec2exe_empty $end
$var reg 1 P exe_pop $end
$var reg 32 Q dec_op1[31:0] $end
$var reg 32 R dec_op2[31:0] $end
$var reg 4 S dec_exe_dest[3:0] $end
$var reg 1 T dec_exe_wb $end
$var reg 1 U dec_flag_wb $end
$var reg 32 V dec_mem_data[31:0] $end
$var reg 4 W dec_mem_dest[3:0] $end
$var reg 1 X dec_pre_index $end
$var reg 1 Y dec_mem_lw $end
$var reg 1 Z dec_mem_lb $end
$var reg 1 [ dec_mem_sw $end
$var reg 1 \ dec_mem_sb $end
$var reg 1 ] dec_shift_lsl $end
$var reg 1 ^ dec_shift_lsr $end
$var reg 1 _ dec_shift_asr $end
$var reg 1 ` dec_shift_ror $end
$var reg 1 a dec_shift_rrx $end
$var reg 5 b dec_shift_val[4:0] $end
$var reg 1 c dec_cy $end
$var reg 1 d dec_comp_op1 $end
$var reg 1 e dec_comp_op2 $end
$var reg 1 f dec_alu_cy $end
$var reg 2 g dec_alu_cmd[1:0] $end
$var reg 32 h exe_res[31:0] $end
$var reg 1 i exe_c $end
$var reg 1 j exe_v $end
$var reg 1 k exe_n $end
$var reg 1 l exe_z $end
$var reg 4 m exe_dest[3:0] $end
$var reg 1 n exe_wb $end
$var reg 1 o exe_flag_wb $end
$var reg 32 p exe_mem_adr[31:0] $end
$var reg 32 q exe_mem_data[31:0] $end
$var reg 4 r exe_mem_dest[3:0] $end
$var reg 1 s exe_mem_lw $end
$var reg 1 t exe_mem_lb $end
$var reg 1 u exe_mem_sw $end
$var reg 1 v exe_mem_sb $end
$var reg 1 w exe2mem_empty $end
$var reg 1 x mem_pop $end
$var reg 1 y ck $end
$var reg 1 z reset_n $end
$var reg 1 { vdd $end
$var reg 1 | vss $end
$var reg 1 } exe2mem_full $end
$var reg 1 !" exe_push $end
$var reg 32 "" mem_adr[31:0] $end
$var reg 32 #" shift_dout_s[31:0] $end
$var reg 1 $" shift_cout_s $end
$var reg 32 %" res_op2_s[31:0] $end
$var reg 32 &" res_op1_s[31:0] $end
$var reg 1 '" res_exe_cout_s $end
$var reg 32 (" res_exe_res_s[31:0] $end
$scope module shifter_inst $end
$var reg 1 )" shift_lsl $end
$var reg 1 *" shift_lsr $end
$var reg 1 +" shift_asr $end
$var reg 1 ," shift_ror $end
$var reg 1 -" shift_rrx $end
$var reg 5 ." shift_val[4:0] $end
$var reg 32 /" din[31:0] $end
$var reg 1 0" cin $end
$var reg 32 1" dout[31:0] $end
$var reg 1 2" cout $end
$var reg 1 3" vdd $end
$var reg 1 4" vss $end
$upscope $end
$scope module alu_inst $end
$var reg 32 5" op1[31:0] $end
$var reg 32 6" op2[31:0] $end
$var reg 1 7" cin $end
$var reg 2 8" cmd[1:0] $end
$var reg 32 9" res[31:0] $end
$var reg 1 :" cout $end
$var reg 1 ;" z $end
$var reg 1 <" n $end
$var reg 1 =" v $end
$var reg 1 >" vdd $end
$var reg 1 ?" vss $end
$var reg 33 @" s1[32:0] $end
$var reg 1 A" cout1 $end
$upscope $end
$scope module exec2mem $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
U"
b00000000000000000000000000000001 #
b00000000000000000000000000000001 $
b1010 %
0&
1'
b00000000000000000000000000000000 (
b0000 )
0*
0+
0,
0-
0.
0/
00
01
02
03
b00000 4
05
06
07
08
b00 9
bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX :
X;
0<
X=
0>
b1010 ?
0@
1A
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU B
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU C
bUUUU D
UE
UF
UG
UH
UI
0J
1K
0L
0M
0N
0O
UP
b00000000000000000000000000000001 Q
b00000000000000000000000000000001 R
b1010 S
0T
1U
b00000000000000000000000000000000 V
b0000 W
0X
0Y
0Z
0[
0\
0]
0^
0_
0`
0a
b00000 b
0c
0d
0e
0f
b00 g
bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX h
Xi
0j
Xk
0l
b1010 m
0n
1o
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU p
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU q
bUUUU r
Us
Ut
Uu
Uv
Uw
0x
1y
0z
0{
0|
U}
0!"
b00000000000000000000000000000001 ""
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU #"
U$"
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU %"
b00000000000000000000000000000001 &"
X'"
bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ("
0)"
0*"
0+"
0,"
0-"
b00000 ."
b00000000000000000000000000000001 /"
00"
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU 1"
U2"
03"
04"
b00000000000000000000000000000001 5"
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU 6"
07"
b00 8"
bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 9"
X:"
0;"
X<"
0="
0>"
0?"
bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX @"
UA"
#2000000
